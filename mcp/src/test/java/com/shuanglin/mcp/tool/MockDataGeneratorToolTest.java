package com.shuanglin.mcp.tool;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.shuanglin.dao.classification.CollectedMessage;
import com.shuanglin.dao.classification.MessageCollectionBatch;
import com.shuanglin.dao.classification.enums.BatchStatus;
import com.shuanglin.dao.classification.enums.MessageCategory;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Mock数据生成工具测试
 */
@DisplayName("Mock数据生成工具测试")
class MockDataGeneratorToolTest {

    private MockDataGeneratorTool tool;
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        tool = new MockDataGeneratorTool();
        objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
    }

    @Test
    @DisplayName("应该生成指定群号的Mock批次")
    void shouldGenerateMockBatchWithGroupId() {
        // Given
        String groupId = "123456789";
        int messageCount = 10;
        String category = "MEME";

        // When
        String result = tool.generateMockMessageBatch(groupId, messageCount, category);

        // Then
        assertNotNull(result);
        assertFalse(result.isBlank());
    }

    @Test
    @DisplayName("生成的批次应该能被解析为MessageCollectionBatch")
    void generatedBatchShouldBeParsable() throws Exception {
        // Given
        String groupId = "123456789";
        int messageCount = 5;
        String category = "MEME";

        // When
        String result = tool.generateMockMessageBatch(groupId, messageCount, category);
        MessageCollectionBatch batch = objectMapper.readValue(result, MessageCollectionBatch.class);

        // Then
        assertNotNull(batch);
        assertEquals(groupId, batch.getGroupId());
        assertEquals(BatchStatus.COMPLETED, batch.getStatus());
    }

    @ParameterizedTest
    @CsvSource({
        "5, 5",
        "10, 10",
        "50, 50",
        "1, 1"
    })
    @DisplayName("应该生成指定数量的消息")
    void shouldGenerateSpecifiedMessageCount(int inputCount, int expectedCount) throws Exception {
        // Given
        String groupId = "123456789";
        String category = "MEME";

        // When
        String result = tool.generateMockMessageBatch(groupId, inputCount, category);
        MessageCollectionBatch batch = objectMapper.readValue(result, MessageCollectionBatch.class);

        // Then
        assertEquals(expectedCount, batch.getMessages().size());
        assertEquals(expectedCount, batch.getMessageCount());
    }

    @ParameterizedTest
    @ValueSource(strings = {"MEME", "HELL_JOKE", "NORMAL", "SPAM"})
    @DisplayName("应该为不同分类生成对应风格的消息")
    void shouldGenerateMessagesForDifferentCategories(String category) throws Exception {
        // Given
        String groupId = "123456789";
        int messageCount = 5;

        // When
        String result = tool.generateMockMessageBatch(groupId, messageCount, category);
        MessageCollectionBatch batch = objectMapper.readValue(result, MessageCollectionBatch.class);

        // Then
        assertNotNull(batch);
        assertNotNull(batch.getMessages());
        assertFalse(batch.getMessages().isEmpty());
    }

    @Test
    @DisplayName("生成的消息应该有完整的字段")
    void generatedMessagesShouldHaveCompleteFields() throws Exception {
        // Given
        String groupId = "123456789";
        int messageCount = 3;
        String category = "MEME";

        // When
        String result = tool.generateMockMessageBatch(groupId, messageCount, category);
        MessageCollectionBatch batch = objectMapper.readValue(result, MessageCollectionBatch.class);

        // Then
        for (CollectedMessage message : batch.getMessages()) {
            assertNotNull(message.getMessageId());
            assertNotNull(message.getUserId());
            assertNotNull(message.getNickname());
            assertNotNull(message.getContent());
            assertNotNull(message.getTimestamp());
        }
    }

    @Test
    @DisplayName("批次ID应该自动生成")
    void batchIdShouldBeAutoGenerated() throws Exception {
        // Given
        String groupId = "123456789";

        // When
        String result1 = tool.generateMockMessageBatch(groupId, 5, "MEME");
        String result2 = tool.generateMockMessageBatch(groupId, 5, "MEME");
        MessageCollectionBatch batch1 = objectMapper.readValue(result1, MessageCollectionBatch.class);
        MessageCollectionBatch batch2 = objectMapper.readValue(result2, MessageCollectionBatch.class);

        // Then
        assertNotNull(batch1.getId());
        assertNotNull(batch2.getId());
        assertNotEquals(batch1.getId(), batch2.getId());
    }

    @Test
    @DisplayName("生成MEME分类消息应该包含搞笑元素")
    void memeCategoryShouldContainFunnyElements() throws Exception {
        // Given
        String groupId = "123456789";
        int messageCount = 10;
        String category = "MEME";

        // When
        String result = tool.generateMockMessageBatch(groupId, messageCount, category);
        MessageCollectionBatch batch = objectMapper.readValue(result, MessageCollectionBatch.class);

        // Then
        boolean hasFunnyContent = batch.getMessages().stream()
                .anyMatch(m -> m.getContent().contains("笑") ||
                        m.getContent().contains("哈") ||
                        m.getContent().contains("图") ||
                        m.getContent().contains("梗"));
        assertTrue(hasFunnyContent, "MEME分类应该包含搞笑内容");
    }

    @Test
    @DisplayName("生成HELL_JOKE分类消息应该包含地狱笑话元素")
    void hellJokeCategoryShouldContainDarkHumor() throws Exception {
        // Given
        String groupId = "123456789";
        int messageCount = 10;
        String category = "HELL_JOKE";

        // When
        String result = tool.generateMockMessageBatch(groupId, messageCount, category);
        MessageCollectionBatch batch = objectMapper.readValue(result, MessageCollectionBatch.class);

        // Then
        boolean hasDarkHumor = batch.getMessages().stream()
                .anyMatch(m -> m.getContent().contains("地狱") ||
                        m.getContent().contains("死") ||
                        m.getContent().contains("坟"));
        assertTrue(hasDarkHumor, "HELL_JOKE分类应该包含地狱笑话元素");
    }

    @Test
    @DisplayName("处理无效分类时应该抛出异常")
    void shouldThrowExceptionForInvalidCategory() {
        // Given
        String groupId = "123456789";
        int messageCount = 5;
        String invalidCategory = "INVALID_CATEGORY";

        // Then
        assertThrows(IllegalArgumentException.class, () -> {
            tool.generateMockMessageBatch(groupId, messageCount, invalidCategory);
        });
    }

    @Test
    @DisplayName("消息数量小于1时应该抛出异常")
    void shouldThrowExceptionForInvalidMessageCount() {
        // Given
        String groupId = "123456789";
        int invalidCount = 0;
        String category = "MEME";

        // Then
        assertThrows(IllegalArgumentException.class, () -> {
            tool.generateMockMessageBatch(groupId, invalidCount, category);
        });
    }

    @Test
    @DisplayName("群号为空时应该抛出异常")
    void shouldThrowExceptionForEmptyGroupId() {
        // Given
        String emptyGroupId = "";
        int messageCount = 5;
        String category = "MEME";

        // Then
        assertThrows(IllegalArgumentException.class, () -> {
            tool.generateMockMessageBatch(emptyGroupId, messageCount, category);
        });
    }
}
